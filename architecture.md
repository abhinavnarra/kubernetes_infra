Architecture of Kubernetes
High-level Kubernetes comprises of the master system and workers. The master system controls the workers and runs applications on them. The desired state of the cluster (compute resources) is represented as abstract objects. These abstract Kubernetes objects are records of intent. Kubernetes will constantly work to ensure that the state represented in these abstract objects is the actual physical state of the cluster. An external client could connect to the master and obtain information about the cluster state and issue commands to change it as per requirement.
Whenever one wishes to update the physical state of the cluster, all they would have to do is update the abstract Kubernetes objects, and Kubernetes will take care of the rest. Let’s dive deeper and briefly discuss the components of the master system and workers.
Components of Kubernetes master
The Kubernetes master system, also known as the control pane, is designed as a set of components. Let’s briefly discuss it’s key components.
API server: Kubernetes mostly uses REST API for internal and external communication. All the abstract Kubernetes objects are exposed as REST resources. API server is the component that is responsible for processing the REST requests, validating them, and performing appropriate CRUD operations on corresponding abstract Kubernetes objects.
Cluster State Store: To perform the CRUD operations, API server would need a backing data store. As the name indicates, cluster state store is a persistent storage instance which stores the state of all the abstract Kubernetes objects configured in the system. The cluster state store has support for watch functionality. Through this functionality, all the coordinating components could be quickly notified whenever a change is made to an object.
Controller Manager: This is the component of master that runs controllers. Controllers run loops and monitor the actual cluster state and state represented in the abstract Kubernetes objects. Whenever a change to cluster state is notified, they are responsible for performing necessary actions, such that the actual state and the abstract state are consistent with each other. Kubernetes has numerous controllers, each one responsible for a different set of Kubernetes objects.
Scheduler: It is the component of the master responsible for allocating physical resources on the cluster to run applications/jobs added to the abstract data store. These scheduling decisions are made taking into account numerous factors like hardware/software constraints, among others.
A Kubernetes master system could have multiple replicas of each of these components to ensure high availability, and could be deployed along with worker node components on a single physical instance. However, for simplicity, setup scripts typically start all master components on the same machine, and do not run any worker instances on this machine.
The exact cluster setup is dependent on the requirements of the end user. For smaller applications, a single instance with both master and worker components is more than sufficient. For larger applications customized effort is essential for configuring the Kubernetes cluster.
Components of Kubernetes worker
The worker instances, or nodes, are also composed of multiple components. The main function of Kubernetes worker components is to process the instructions from master and execute them on the node. The following are the key components of a worker node:
Kubelet: It is the component of worker responsible for making sure that the containers scheduled by the master on this node are running and are healthy.
Container runtime: Container runtime is the software that is responsible for running containers. Kubernetes supports several runtimes and any implementation of the Kubernetes CRI. Each worker node uses this to run the containerized applications scheduled by the master. Running non-containerized applications is discouraged and not supported by Kubernetes.
Kube proxy: It is the component of Worker responsible for maintaining network rules on the worker and performing connection forwarding. This essentially enables efficient and effective communication throughout the cluster. External application traffic will get redirected to the appropriate container through these components.
External Kubernetes client
Theoretically, external Kubernetes client could be any application that can communicate with API server through the well-defined REST API. But the most predominant choice is to use Kubectl.
Kubectl is a command line tool that is intended to be used by an end-user responsible for managing application deployments. Kubectl users can execute commands on a terminal. Each of these commands is converted into an API call in the background and sent to the API server on Kubernetes master, where necessary action will be performed.

High-Level Kubernetes Architecture
Let’s take a step back and look at the overall architecture of Kubernetes. One could notice that it is designed as a set of loosely coupled components working together, instead of a single monolithic instance being responsible for all the functionality. We already discussed the various advantages of such an architectural style. In particular, this choice allows Kubernetes to stay flexible and extensible.
The choice to use rest to create and update the cluster configuration ensures that any configuration created on one environment will work on any other environment. This allows application deployments created on Kubernetes to remain portable.
Controller manager and scheduler act as components which continuously watch for changes to the abstract objects in cluster state store. They send instructions to worker nodes whenever necessary to automatically update the actual state of cluster This design choice eliminates a great deal of manual work and ensure Kubernetes is autonomic. In fact, this declarative approach to cluster management was one of the main features which lead to the rapid adoption of Kubernetes.
The choice to run only containerized applications by interacting with the container runtime through an interface ensures that any type of application could run on Kubernetes, and allows Kubernetes to remain general purpose.
We can now look into the abstract objects used to represent and manage the cluster state in Kubernetes. Knowledge of these Kubernetes objects is the final piece of the puzzle we need to understand before we dive into the example
